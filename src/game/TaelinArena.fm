import Base#9y4x
import TaelinArena.Geometry
import TaelinArena.Game
import TaelinArena.ModelIds
import TaelinArena.Thing

// Apply a player input to the game state
exec_command(cmd: Command, gm: Game) : Game
  case cmd |command
  let fn = (thi: Thing) =>
    case cmd.inp as inp
    with thi : Thing
    | sdir =>
      case thi |thing
      let is_idle = len_v3(inp.dir) === 0
      let map_dir = (d: V3) => if is_idle then d else inp.dir
      let map_wlk = (s: Bool) => if is_idle then false else true
      let thi = thi <= thing(dir = map_dir(dir))
      let thi = thi <= thing(wlk = map_wlk(wlk))
      thi
    | key0 => thi <= thing(
      trg = if act === 0 then inp.pos else trg,
      act = if act === 0 then 1 else act,
      tik = if act === 0 then 0 else tik)
    | key1 => thi <= thing(
      trg = if act === 0 then inp.pos else trg,
      act = if act === 0 then 2 else act,
      tik = if act === 0 then 0 else tik)
    | key2 => thi <= thing(
      trg = if act === 0 then inp.pos else trg,
      act = if act === 0 then 3 else act,
      tik = if act === 0 then 0 else tik)
    | key3 => thi <= thing(
      trg = if act === 0 then inp.pos else trg,
      act = if act === 0 then 4 else act,
      tik = if act === 0 then 0 else tik)
    | key4 => thi <= thing(
      trg = if act === 0 then inp.pos else trg,
      act = if act === 0 then 5 else act,
      tik = if act === 0 then 0 else tik)
    | key5 => thi <= thing(
      trg = if act === 0 then inp.pos else trg,
      act = if act === 0 then 6 else act,
      tik = if act === 0 then 0 else tik)
    | cmsg => thi
  with_thing(cmd.pid, fn, gm)

// Interaction function between two things
interact_with(this:Thing, that:Thing): Thing
  // Physical collisions
  let this =
    case this |thing
    case that |thing
      case this.box |cbox
      case that.box |cbox
        let dst = dist_v3(this.pos, that.pos)
        let rad = this.box.rad + that.box.rad
        if (dst > 0) && (dst < rad) then
          let out_dir = norm_v3(sub_v3(this.pos, that.pos))
          let out_vec = scale_v3(rad - dst, out_dir)
          let new_pos = add_v3(this.pos, out_vec)
          this <= thing(pos = new_pos)
        else
          this
      | pbox => this
      | pbox => this

  // Hit by an attack
  let this =
    case this |thing
    case that |thing
    case that.hit |none this |some
    case that.hit.value
    | pointed_hit => // TODO: implement
      this
    | outward_hit =>
      let dst = sqrdist_v3(that.pos, this.pos)
      let rad = that.hit.value.rad
      if dst < (rad * rad) then
        let dir = lookat_v3(that.pos, this.pos, v3(1,0,0))
        let vec = scale_v3(that.hit.value.mag, dir)
        this <= thing(knk = vec)
      else
        this
  this

// Like a fold, but with access to a list of other elements
interact_list(A; B;
  i: B,
  f: A -> List(A) -> B -> B,
  xs: List(A),
  ys: List(A) -> List(A)
  ) : B
  case xs
  | nil  => i
  | cons =>
    let self = xs.head
    let tail = xs.tail
    let ys2  = (x) => ys(cons(_ xs.head, x))
    let rest = interact_list(A; B; i, f, xs.tail, ys2)
    f(xs.head, ys(xs.tail), rest)

// Game's main loop
exec_turn(gm: Game) : Game
  // Interaction function
  let intr = (that,this) => interact_with(this,that)

  // For each thing in the game...
  let tick = (thi: Thing, stage: List(Thing), res: List(Thing)) =>
    case thi |thing

    // Calls the transaction function
    let thi = thi.fun(thi)

    // Integrates position with dash velocity
    let thi = thi <= thing(pos = add_v3(pos,vel))

    // Integrates position with walk vector
    let thi = thi <= thing(pos = case wlk
      | true  => add_v3(pos,scale_v3(mov*bst,dir))
      | false => pos)

    // Integrates position with knockback
    let thi = thi <= thing(
      pos = add_v3(pos, knk),
      knk = scale_v3(0.80, knk))

    // Calls interaction function with all other things
    let thi = fold(Thing; _ thi, intr, stage)

    // Increments tik counter
    let thi = thi <= thing(tik = tik + 1)

    // Spawns children
    case thi |thing
    let chi_init = (chi) => case chi |thing chi.fun(chi)
    let chi_list = map(Thing; Thing; chi_init, thi.chi)

    // Keeps inside map
    let thi = thi <= thing(pos =
      case pos |v3
      let x = min(max(-448, pos.x), 448)
      let y = min(max(-192, pos.y), 192)
      let z = min(max(   0, pos.z), 256)
      v3(x, y, z))
    
    // Adds updated thing and new things to stage
    concat(_ chi_list,
      case thi.die
      |true res
      |false cons(_thi,res))

  // Ticks every thing on stage
  gm <= game(
    stage = interact_list(Thing; _ [], tick, stage, (x)=>x))

// Returns the draw object with info to render on screen
draw_thing(thi: Thing) : Draw 
  case thi |thing
  let mid = thi.mid
  let pos = thi.pos
  let dir =
    if thi.act === 0 then
      thi.dir
    else
      lookat_v3(thi.pos, thi.trg, thi.dir)
  let lit = thi.lit
  let dmg = thi.dmg
  draw(mid, pos, dir, lit, dmg)

// Creates a brand new game
new_game(tids: List(ThingId)) : Game
  let nil = (pid) => []
  let cons = (tid, heroes, pid) => 
    let hpid = pid
    let hpos = v3((pid * 80) - 80, 0, 0)
    let hero = init_thing(tid) <= thing(pid=hpid, pos=hpos)
    let rest = heroes(pid + 1)
    cons(_ hero, rest)
  game(fold(_ Number -> List(Thing); nil, cons, tids, 0))
